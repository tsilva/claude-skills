#!/usr/bin/env python3
"""
Pre-commit hook for validating plugin version bumps.

Validates that when skill files are modified:
1. The version is bumped (new version > old version)
2. All 3 version locations are consistent:
   - plugins/{plugin}/skills/{skill}/SKILL.md (metadata.version)
   - plugins/{plugin}/.claude-plugin/plugin.json (version)
   - .claude-plugin/marketplace.json (version for that plugin)
"""

import json
import re
import subprocess
import sys
from pathlib import Path


def parse_version(version_str: str) -> tuple[int, int, int]:
    """Parse a version string into (major, minor, patch) tuple."""
    version_str = version_str.strip().strip('"').strip("'")
    parts = version_str.split(".")
    if len(parts) != 3:
        raise ValueError(f"Invalid version format: {version_str}")
    return int(parts[0]), int(parts[1]), int(parts[2])


def version_greater(new_version: str, old_version: str) -> bool:
    """Check if new_version > old_version using semver comparison."""
    try:
        new = parse_version(new_version)
        old = parse_version(old_version)
        return new > old
    except ValueError:
        return False


def extract_version_from_skill_md(content: str) -> str | None:
    """Extract version from SKILL.md frontmatter content."""
    match = re.search(r"^---\s*\n(.*?)\n---", content, re.DOTALL)
    if not match:
        return None

    frontmatter = match.group(1)
    version_match = re.search(r'^\s*version:\s*["\']?([^"\'\n]+)["\']?', frontmatter, re.MULTILINE)
    if version_match:
        return version_match.group(1).strip()
    return None


def extract_version_from_plugin_json(content: str) -> str | None:
    """Extract version from plugin.json content."""
    try:
        data = json.loads(content)
        return data.get("version")
    except json.JSONDecodeError:
        return None


def extract_version_from_marketplace(content: str, plugin_name: str) -> str | None:
    """Extract version for a specific plugin from marketplace.json content."""
    try:
        data = json.loads(content)
        for plugin in data.get("plugins", []):
            if plugin.get("name") == plugin_name:
                return plugin.get("version")
        return None
    except json.JSONDecodeError:
        return None


def get_staged_file_content(file_path: str) -> str | None:
    """Get content of a file as staged (index)."""
    result = subprocess.run(
        ["git", "show", f":{file_path}"],
        capture_output=True,
        text=True
    )
    if result.returncode != 0:
        return None
    return result.stdout


def get_committed_file_content(file_path: str) -> str | None:
    """Get content of a file as last committed (HEAD)."""
    result = subprocess.run(
        ["git", "show", f"HEAD:{file_path}"],
        capture_output=True,
        text=True
    )
    if result.returncode != 0:
        return None
    return result.stdout


def get_staged_files() -> list[str]:
    """Get list of staged files."""
    result = subprocess.run(
        ["git", "diff", "--cached", "--name-only"],
        capture_output=True,
        text=True
    )
    if result.returncode != 0:
        return []
    return [f.strip() for f in result.stdout.strip().split("\n") if f.strip()]


def extract_plugins_from_paths(paths: list[str]) -> set[str]:
    """Extract plugin names from file paths matching plugins/{plugin-name}/."""
    plugins = set()
    pattern = re.compile(r"^plugins/([^/]+)/")
    for path in paths:
        match = pattern.match(path)
        if match:
            plugins.add(match.group(1))
    return plugins


def find_skill_name(plugin_name: str) -> str | None:
    """Find the skill name for a plugin by checking the skills directory."""
    skills_dir = Path(f"plugins/{plugin_name}/skills")
    if not skills_dir.exists():
        return None

    for skill_dir in skills_dir.iterdir():
        if skill_dir.is_dir() and (skill_dir / "SKILL.md").exists():
            return skill_dir.name
    return None


def validate_plugin(plugin_name: str) -> list[str]:
    """Validate version for a plugin. Returns list of error messages."""
    errors = []

    skill_name = find_skill_name(plugin_name)
    if not skill_name:
        # Plugin doesn't have a SKILL.md, skip validation
        return []

    skill_md_path = f"plugins/{plugin_name}/skills/{skill_name}/SKILL.md"
    plugin_json_path = f"plugins/{plugin_name}/.claude-plugin/plugin.json"
    marketplace_path = ".claude-plugin/marketplace.json"

    # Get staged versions
    staged_skill_content = get_staged_file_content(skill_md_path)
    staged_plugin_content = get_staged_file_content(plugin_json_path)
    staged_marketplace_content = get_staged_file_content(marketplace_path)

    # Get committed versions
    committed_skill_content = get_committed_file_content(skill_md_path)
    committed_plugin_content = get_committed_file_content(plugin_json_path)
    committed_marketplace_content = get_committed_file_content(marketplace_path)

    # Extract staged versions
    staged_versions = {}
    if staged_skill_content:
        v = extract_version_from_skill_md(staged_skill_content)
        if v:
            staged_versions["SKILL.md"] = v

    if staged_plugin_content:
        v = extract_version_from_plugin_json(staged_plugin_content)
        if v:
            staged_versions["plugin.json"] = v

    if staged_marketplace_content:
        v = extract_version_from_marketplace(staged_marketplace_content, plugin_name)
        if v:
            staged_versions["marketplace.json"] = v

    # Extract committed versions
    committed_versions = {}
    if committed_skill_content:
        v = extract_version_from_skill_md(committed_skill_content)
        if v:
            committed_versions["SKILL.md"] = v

    if committed_plugin_content:
        v = extract_version_from_plugin_json(committed_plugin_content)
        if v:
            committed_versions["plugin.json"] = v

    if committed_marketplace_content:
        v = extract_version_from_marketplace(committed_marketplace_content, plugin_name)
        if v:
            committed_versions["marketplace.json"] = v

    # New plugin case: no committed version, only check consistency
    is_new_plugin = len(committed_versions) == 0

    # Check that all 3 staged version locations exist and are consistent
    unique_staged_versions = set(staged_versions.values())
    if len(unique_staged_versions) > 1:
        errors.append(f"[{plugin_name}] Version mismatch across files:")
        for loc, v in staged_versions.items():
            errors.append(f"    {loc}: {v}")
        errors.append("  All 3 locations must have the same version.")
        return errors

    if len(staged_versions) < 3:
        missing = {"SKILL.md", "plugin.json", "marketplace.json"} - set(staged_versions.keys())
        if missing:
            errors.append(f"[{plugin_name}] Missing version in: {', '.join(sorted(missing))}")
            errors.append("  All 3 locations must be updated together.")
            return errors

    # Skip version bump check for new plugins
    if is_new_plugin:
        return []

    # Get the staged version (they're all the same at this point)
    staged_version = list(staged_versions.values())[0] if staged_versions else None

    # Get the committed version from SKILL.md (primary source)
    committed_version = committed_versions.get("SKILL.md")

    if staged_version and committed_version:
        if not version_greater(staged_version, committed_version):
            errors.append(f"[{plugin_name}] Version not bumped: {committed_version} -> {staged_version} (new version must be greater)")
            errors.append(f"  Run: python plugins/claude-skill-author/skills/claude-skill-author/scripts/bump-version.py {plugin_name} --type patch")

    return errors


def main():
    staged_files = get_staged_files()
    if not staged_files:
        sys.exit(0)

    # Extract plugins that have staged changes
    affected_plugins = extract_plugins_from_paths(staged_files)
    if not affected_plugins:
        sys.exit(0)

    # Validate each plugin
    all_errors = []
    for plugin in sorted(affected_plugins):
        errors = validate_plugin(plugin)
        all_errors.extend(errors)

    if all_errors:
        print("=" * 60)
        print("PRE-COMMIT HOOK: Version validation failed")
        print("=" * 60)
        print()
        for error in all_errors:
            print(error)
        print()
        print("=" * 60)
        print("Commit rejected. Please bump version(s) and re-stage.")
        print("=" * 60)
        sys.exit(1)

    sys.exit(0)


if __name__ == "__main__":
    main()
